# Алгоритм Хаффмана
Программа реализует алгоритм сжатия Хаффмана. Закодированный файл содержит всю информацию, необходимую для восстановления исходных данных: длину закодированных данных, сами данные и таблицу частот для восстановления дерева Хаффмана.
## Запуск
javac *.java
java HuffmanTest
## Использование
java Main режим входной_файл выходной_файл
## Примеры
#### java Main encode document.txt compressed.bin - кодирование
#### java Main decode compressed.bin document_restored.txt - декодирование
## 1. Количество уникальных символов
```
Позиция: Байты 0-3
Формат: 4 байта, big-endian, тип int
Назначение: Указывает количество различных байтов в исходном файле
Пример: 0x00000003 = 3 уникальных символа
```
## 2. Таблица частот (повторяется для каждого символа)
```
Для каждого уникального символа сохраняется:
2.1. Символ
Позиция: 1 байт после предыдущего элемента
Формат: 1 байт, тип byte
Назначение: Исходное значение байта (0-255)
Пример: 0x31 = символ '1'

2.2. Частота символа
Позиция: 4 байта после символа
Формат: 4 байта, big-endian, тип int
Назначение: Количество вхождений данного символа
Пример: 0x0000000A = 10 вхождений
```
## 3. Длина битовой строки
```
Позиция: Сразу после таблицы частот
Формат: 4 байта, big-endian, тип int
Назначение: Количество значимых бит в закодированных данных
Пример: 0x0000001E = 30 бит
```
## 4. Закодированные данные
```
Позиция: Сразу после длины битовой строки
Формат: Массив байтов переменной длины
Назначение: Содержит закодированные данные
Правила упаковки:
Биты упаковываются в байты слева направо
Старший бит (бит 7) первого байта соответствует первому биту закодированных данных
Младший бит (бит 0) последнего байта может содержать дополняющие нули
Фактическое количество значимых бит указано в поле "Длина битовой строки"
```
## Пример для файла "11111111112222233333"
### Исходные данные:
```
20 байт: 31 31 31 31 31 31 31 31 31 31 32 32 32 32 32 33 33 33 33 33
Закодированный файл (27 байт):
Байт   HEX     Двоичный                    Описание
0-3    00 00 00 03  00000000 00000000 00000000 00000011  Количество символов: 3
4      31        00110001                              Символ '1' (0x31)
5-8    00 00 00 0A 00000000 00000000 00000000 00001010  Частота '1': 10
9      32        00110010                              Символ '2' (0x32)
10-13  00 00 00 05 00000000 00000000 00000000 00000101  Частота '2': 5
14     33        00110011                              Символ '3' (0x33)
15-18  00 00 00 05 00000000 00000000 00000000 00000101  Частота '3': 5
19-22  00 00 00 1E 00000000 00000000 00000000 00011110  Длина данных: 30 бит
23     00        00000000                              Байт 1 данных
24     28        00101000                              Байт 2 данных  
25     FF        11111111                              Байт 3 данных
26     C0        11000000                              Байт 4 данных
Побитовая интерпретация закодированных данных:
Закодированные данные (4 байта):
Байт 23: 00000000
Байт 24: 00101000  
Байт 25: 11111111
Байт 26: 11000000

Объединяем биты: 00000000 00101000 11111111 11000000
Берем 30 бит (из поля длины): 00000000 00101000 11111111 11

Разбиваем по кодам Хаффмана:
'1' = "0"
'2' = "10"  
'3' = "11"

Декодирование:
0000000000 = 10×'1'  (10 бит "0")
1010101011 = 5×'2' + 3×'3' (чередующиеся "10" и "11")
111111 = оставшиеся 2×'3' (6 бит "11")
```
## Ограничения
```
Максимальный размер файла: ~2GB (ограничение int для длины)
Максимальная частота символа: 2³²-1
Максимальное количество уникальных символов: 2³²-1
```





